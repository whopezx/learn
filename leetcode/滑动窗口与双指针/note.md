# 滑动窗口与双指针
## 定长滑动窗口
### 1456
定长字串中元音的最大数目，这道题主要是判断滑动时新加入的元素和移除的元素是否是元音，中间的字母无需每次判断，每次滑动只有两边的字母变化，所以结果加$1$或减$1$即可，然后判断是否更新最大值。

### 643
子数组最大平均值，使用定长滑动窗口的通用解法即可容易完成。

### 1343
大小为k且平均值大于等于阈值的子数组数目，使用定长滑动窗口的通用解法即可容易完成

### 2090
半径为k的子数组平均值，注意窗口大小为$2k+1$即可，其他使用定长滑动窗口的通用解法即可容易完成

### 2379
得到K个黑块的最少涂色次数，这里学到了程序在执行判断时会预测执行哪个分支，如果预测对了则执行，但是预测错了会回滚，然后执行其他的分支，这样导致计算耗时增加。其他使用定长滑动窗口的通用解法即可完成

### 2841
几乎唯一子数组的最大和，这里学到了python中使用set(List)可以得到这个列表中唯一元素的数目，并且python中set是一种数据类型，‘集合’，通过大括号创建，即`{1,2,3,4,1}`打印会得到`{1,2,3,4}`，即得到唯一元素。这道题使用哈希表来统计元素出现的数目，进而计算独特数目的元素会比set快得多。其他求和还是使用定长滑动窗口的通用解法即可完成。

### 2461
长度为 K 子数组中的最大和，和2841类似，这道题我有点小改进，即由于需要子数组中需要都是不同的元素，所以在最后判断有key但value等于零时，改成直接删掉这个key-value即可，因为对于满足条件的子数组去除移除的元素后，这个key对应的value必然为零。

### 1423
可获得的最大点数，这道题需要思考一下取数的本质，其他的不困难，使用定长滑动窗口的通用解法即可完成。

### 3679
使库存平衡的最少丢弃次数，这道题用到了贪心算法，我在解题时并没有考虑到，也就是当一个区间内出现相同货物的次数大于给定次数时，直接丢弃后来的货物还是时间回溯到之前的货物刚到时丢弃之前的货物。对于这道题丢弃后来的货物，丢的次数会更少。例如`[9,9,8,9]`，窗口大小为3，最多货物存储为1，那么第一天`[9]`时不用丢弃，第二天`[9,9]`时丢弃后面的9变为`[9]`，第三天`[9,8]`不用丢弃，第四天`[8,9]`不用丢弃。如果时间回溯丢弃之前的货物，则第一天一样，第二天时丢弃前面的9变为`[9]`，第三天时`[9,8]`不用丢弃，第四天时`[8,9]`丢弃前面的9，这样比刚才的方案多丢弃一次。

同时还学到python中in关键字对于字典，集合，字符串都是O(1)的时间复杂度，但是对于列表和元组时间复杂度都为O(n)，其中n为列表或元组的长度。所以使用in关键词判断某个元素是否在列表或者元组中时，最好将列表或元组转为字典或哈希表类型。

最后由于这道题会丢弃货物，所以在窗口移出时不能直接将$i-w+1$的元素从哈希表中移除，需要先判断这个货物是否被丢弃。看题解中比较好的编程思路是将丢弃的货物的arrivals[i]设为0或者负值，这样后面移出时判断arrivals是否大于0就可以得到这个位置的货物有没有被丢弃，如果被丢弃了则在哈希表中不进行移除。

### 2200
找出数组中的所有 K 近邻下标，这道题设置一个2k+1长度的窗口，由于需要取key前k个和后k个下标，这道题的解法让出现key的时候出现在2k+1位置，然后下标的窗口移动。

### 2269
找到一个数字的 K 美丽值，比较简单。

### 1984
学生分数的最小差值，<font color="red">这道题看过题解之后才写出来</font>，题目是随机选分数，但是我们可以通过排序来有规律的进行选择，其他和定长滑动窗口一样。

### 1461
检查一个字符串是否包含所有长度为 K 的二进制子串，这里学到哈希表用整数做key时比用字符串做key更快，
根据题解，将长度为k的字符串作为key存入哈希表时，时间复杂度为O(k)。
还学到python的ord函数可以将字符串转为ascii码。

## 不定长滑动窗口
### 3
无重复字符的最长子串，从这道题来看，感觉不定长滑动窗口像是定长滑动窗口延迟滑动出的过程，不过需要对出的过程进行再次循环。我这里出的过程使用if+for还是不清晰，使用while代码更可读一点。

### 3090
每个字符最多出现两次的最长子字符串，和上面的第3题一样，上面是最多出现一次，这道题是最多出现两次，代码中出的判断大于2即可。

### 1493
删掉一个元素以后全为 1 的最长子数组，这道题实际上是一个窗口中最多含有一个零是，这个窗口的最大长度减一（这道题要求即使没有零也需要去掉一个元素），按照一般的不定长滑动窗口求解即可。不过这道题实际上无需使用哈希表记录，使用一个变量来记录即可（参考灵茶山艾府的题解）。

### 3634
使数组平衡的最少移除数目，这道题与定长滑动窗口的1984类似，都是先排序，然后按照滑动窗口的一般做法解题即可。这道题与灵茶山艾府的题解思路完全相同。

### 1208
尽可能使字符串相等，这里学到了python计算字符串ASCII码的函数是`ord()`，这道题比较简单，一般不定长滑动窗口解即可，注意绝对值。

### 904
水果成篮，比较简单

### 1695
删除子数组的最大得分，在最后计算得分时，直接使用`sum(cnt)`和加进入的元素然后遇到相同元素时减去出的元素的耗时差很多，看来直接对哈希表的key做求和比较慢，之前的题目中也是这样，对哈希表的value求和时也比较慢。

### 2958
最多 K 个重复元素的最长子数组，比较简单

### 2024
考试的最大困扰度，比较简单，并且这道题没有使用之前的哈希表来存储，仅维护了两个变量`T`和`F`来计数，这样可以提高计算速度。唯一需要思考一下的就是，当`T>k and F>k`才达到最大长度。

### 1004
最大连续 1 的个数 III，和2024题一样，比较简单

### 1658
将 x 减到 0 的最小操作数，<font color="red">这道题看过题解之后才写出来</font>，这道题正向做法是使用双指针来计算，不过这道题由于分在了不定长滑动窗口中，我还是希望使用不定长滑动窗口来做。对于正向想法，即从左边和右边加元素使之恰好等于`x`，或本来小于`x`再额外加一个元素就会大于`x`的长度。这样对于滑动窗口来说就非常困难。

参考灵茶山艾府的题解，找到最小的上述元素长度，即找到最长元素和为`sum(nums)-x`或再额外加一个元素就大于`sum(nums)-x`的子数组，这就是反向想法。无需像1423题一样重排`nums`，就是对本来的`nums`进行选取即可。还需要注意的是要判断`sum(nums)>x`即`nums`中所有元素的和要大于`x`，否则选取全部元素也不能满足要求。

### 2730
找到最长的半重复子字符串，这道题稍微需要思考一下，子字符串长度至少为1，所以循环从1开始。由于一开始将`left`设为1所以在判断相邻两个元素重复的数目时比较容易，直接`left+=1`即可，但是这样做会带来一个问题，例如字符串`1122345`，在循环至第二个`2`时，`repeat=2`，这时判断`s[left]==s[left-1]`，由于`left=1`，所以`s[left]=1`，`s[left-1]=1`，进而`repeat-1`，最后`left`右移1。目前`left=2`，但是实际上我们应该把第二个`1`包含进来，所以在计算`ans`时会有`(left-1)`。

### 209
长度最小的子数组，这道题不算困难，滑动窗口的部分很简单，需要思考一下什么时候更新ans，并且如何更新ans。

### 2779
数组的最大美丽值，这道题看代码来说比较简单，但是思考起来不容易，我卡了好久。首先一个难点就是子序列，由于不要求连续了，所以为了不反复遍历数组，排序是一个关键。排序后有规律了就可以使用变长滑动窗口了。第二个地方卡了很久，遍历元素时，无需像注释那样考虑这个元素向左向右能取多少美丽值，直接固定left，向右取值即可。第三个地方就是提交后发现美丽值的定义，例如`nums = [49,26], k = 12`中49-12=37，26+12=38，所以这两个元素是有交集的，所以在判断left的移动时需要`2*k`

### 2904
最短且字典序最小的美丽子字符串，这道题需要注意字符串前的0是如何去掉的，通过在while的判断中添加`s[left]==0`来删掉额外的0，但是这时要求如果字符串中不能全为0，否则会导致left一直加，直到超出字符串范围。通过在开始加判断来避免这一情况。

### 713
乘积小于 K 的子数组，这道题有两个地方需要注意。第一个也是最主要的，随着我们增加元素到子窗口满足题意的子数组为，当前元素`[nums[i]]`，当前元素和前一个元素组成的子数组`[nums[i-1], nums[i]]`相乘，以此类推`[nums[0]...nums[i]]`相乘，一共有`i+1`（从0开始）个子数组（`i`往右移时，前面的子数组都统计过了，例如`[nums[0]...nums[i-1]]`），但存在一个问题，随着子数组越来越长，`[nums[0]...nums[i]]`的相乘会不满足题意，这时`left`向右移，直到`left`移动到满足题意，即`[nums[left]...nums[i]]`相乘小于`k`，这时一共会有`i-left+1`个子数组。第二个是题目中给出数组`nums`中的元素都是大于等于1的，所以当`k<=1`时都是不满足条件的，可以在开头设置当k小于等于1时直接返回0，或者在内循环中加判断让left不要超过i。

### 3258
统计满足 K 约束的子字符串数量 I，和上面713题的思路一样，不过更简单了。

### 1358
包含所有三种字符的子字符串数目，这道题只有一个地方需要理解，不过这个很重要。当移动后窗口为[left, i]时（注意是移动后，也就是内层循环结束，或者在这次外层循环中根本不会运行内层循环），这样的窗口是不满足题意的，而[left-1, i]是满足题意的（除了left=0），并且[left-2, i], [left-3, i], ... [0, i]都是满足题意的，这一共有left个。对于类似'aaabc'这样的字符串好理解，但是对于'abccc'这样的字符串则稍微困难，开始时我会想'abc', 'abcc', 'abccc'是满足题意的，但是这样与前面的情况完全不同。所以重新按照前面的思路来理解，当第一次窗口移动时'bc'是不满足题意的，'abc'是满足题意的，这时left=1，这个1就是'abc'，外层循环增加一个，窗口变为'bcc'，这时不会触发内层循环，所以left=1，是'abcc'，直到最后'bccc'，不会触发内层循环，left=1，对应是'abccc'。这时可以容易看出，实际上对于每次外层循环，left的值都是上一次外层循环的子字符串由于添加新字符，能够形成的新的子字符串的值。感觉和713，3258题是互补的一个过程。

### 930
和相同的二元子数组，这道题我想了很久，想直接找到题目要求的子数组的数目，但是没发现什么方法能直接算出，所以还是参考了灵茶山艾府的思路写了程序（虽然没有直接参考程序，但是也是看了思路写出来的）。对于这种恰好为某种情况的滑动窗口，可以使用前面两种类型（1358对应的越长越合，713和3258对应的越短越合）的题目进行求解。题目要求当子数组对应的和恰好为`goal`时的数目，我们可以利用越长越合计算出大于`goal`的子数组的数目和大于`goal+1`子数组的数目然后相减即可得到恰好等于`goal`的子数组的数目。同样可以利用越短越合计算出小于`goal`子数组的数目和小于`goal-1`子数组的数目然后相减即可得到恰好等于`goal`子数组的数目。