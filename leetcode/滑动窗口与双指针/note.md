# 滑动窗口与双指针
### 1456
定长字串中元音的最大数目，这道题主要是判断滑动时新加入的元素和移除的元素是否是元音，中间的字母无需每次判断，每次滑动只有两边的字母变化，所以结果加$1$或减$1$即可，然后判断是否更新最大值。

### 643
子数组最大平均值，使用定长滑动窗口的通用解法即可容易完成。

### 1343
大小为k且平均值大于等于阈值的子数组数目，使用定长滑动窗口的通用解法即可容易完成

### 2090
半径为k的子数组平均值，注意窗口大小为$2k+1$即可，其他使用定长滑动窗口的通用解法即可容易完成

### 2379
得到K个黑块的最少涂色次数，这里学到了程序在执行判断时会预测执行哪个分支，如果预测对了则执行，但是预测错了会回滚，然后执行其他的分支，这样导致计算耗时增加。其他使用定长滑动窗口的通用解法即可完成

### 2841
几乎唯一子数组的最大和，这里学到了python中使用set(List)可以得到这个列表中唯一元素的数目，并且python中set是一种数据类型，‘集合’，通过大括号创建，即`{1,2,3,4,1}`打印会得到`{1,2,3,4}`，即得到唯一元素。这道题使用哈希表来统计元素出现的数目，进而计算独特数目的元素会比set快得多。其他求和还是使用定长滑动窗口的通用解法即可完成。

### 2461
长度为 K 子数组中的最大和，和2841类似，这道题我有点小改进，即由于需要子数组中需要都是不同的元素，所以在最后判断有key但value等于零时，改成直接删掉这个key-value即可，因为对于满足条件的子数组去除移除的元素后，这个key对应的value必然为零。

### 1423
可获得的最大点数，这道题需要思考一下取数的本质，其他的不困难，使用定长滑动窗口的通用解法即可完成。

### 3679
使库存平衡的最少丢弃次数，这道题用到了贪心算法，我在解题时并没有考虑到，也就是当一个区间内出现相同货物的次数大于给定次数时，直接丢弃后来的货物还是时间回溯到之前的货物刚到时丢弃之前的货物。对于这道题丢弃后来的货物，丢的次数会更少。例如`[9,9,8,9]`，窗口大小为3，最多货物存储为1，那么第一天`[9]`时不用丢弃，第二天`[9,9]`时丢弃后面的9变为`[9]`，第三天`[9,8]`不用丢弃，第四天`[8,9]`不用丢弃。如果时间回溯丢弃之前的货物，则第一天一样，第二天时丢弃前面的9变为`[9]`，第三天时`[9,8]`不用丢弃，第四天时`[8,9]`丢弃前面的9，这样比刚才的方案多丢弃一次。

同时还学到python中in关键字对于字典，集合，字符串都是O(1)的时间复杂度，但是对于列表和元组时间复杂度都为O(n)，其中n为列表或元组的长度。所以使用in关键词判断某个元素是否在列表或者元组中时，最好将列表或元组转为字典或哈希表类型。

最后由于这道题会丢弃货物，所以在窗口移出时不能直接将$i-w+1$的元素从哈希表中移除，需要先判断这个货物是否被丢弃。看题解中比较好的编程思路是将丢弃的货物的arrivals[i]设为0或者负值，这样后面移出时判断arrivals是否大于0就可以得到这个位置的货物有没有被丢弃，如果被丢弃了则在哈希表中不进行移除。